---
title: 操作系统 | IO多路复用
date: 2023-04-17 08:29:59
tags:
  - 操作系统
---

## 最基本的Socket模型

Socket模型相比管道、共享内存、信号量等方式，实现了跨主机进程之间的通信，但是他是**阻塞IO模型**，基本上只能一对一通信，当发生读写阻塞时，会导致其他客户端请求无法处理，无法建立新的连接。

## 传统方式

传统方式每一个客户端连接，就分配一个进程或者线程，通过多线程、多进程方式实现一对多的通信。

### 多进程模型

主要思路如下：

- 服务器主线程负责监听客户端连接，建立连接后accept函数返回一个已连接的socket
- 同时fork出一个子进程，子进程复制了父进程相关的资源，通过父进程的文件描述符实现了与客户端通信

在子进程退出时，需要做好回收工作，否则变成**僵尸进程**，会占用系统资源。

> 僵尸进程：子进程先于父进程结束时，子进程的退出状态信息会被保留，但其父进程没有及时对其进行处理，导致子进程变为僵尸进程。僵尸进程不再执行任何代码，但其占用系统资源，如进程表中的一个记录。

随着客户端数量增多，每产生一个进程会占用一定的系统资源，并且进程间的上下文成本很高，性能会收到影响。因此多进程模型并不合适。

### 多线程模型

多进程的上下文切换成本很高，可以联想到多线程模型。同进程里的线程可以共享进程的部分资源，比如文件描述符列表、进程空间、代码、全局数据、堆、共享库等，这些共享些资源在上下文切换时不需要切换，而只需要切换线程的私有数据、寄存器等不共享的数据。

主要思路如下：

- 主线程负责监听客户端连接，当完成客户端TCP连接后，创建线程，传递已连接的socket的文件描述符给线程函数
- 在线程里完成与客户端的通信，达到并发处理

每次连接来创建一个线程，结束后在销毁，创建和销毁的成本较高，由此引入了**线程池**概念，提前创建若干个线程，通过复用线程减少性能损失。由于队列是全局的，为了避免多线程竞争，线程在操作时需要加锁。

但是实际中在高并发场景下，维护1万个进程或者线程，操作系统都是无法扛得住的。由此引入了I/O多路复用技术。

## I/O多路复用

通过一个进程维护多个socket通信。每个进程控制每个请求处理耗时，并发处理多个请求，实现一个时分多路复用，类似一个CPU并发处理多个进程。

总体思路：将所有已经建立的连接（文件描述符）传递给内核，再由内核返回产生事件的连接，最终在用户态处理连接对应的请求。

### select

大致思路如下：

- 将已连接的 Socket 都放到一个**文件描述符集合**，然后调用 select 函数将文件描述符集合**拷贝**到内核里，让内核通过**遍历集合**是否有网络事件产生，将对应产生事件的socket标为可读或者可写
- 再将文件描述符拷回用户态，用户态经过**遍历集合**找到可读或者可写的socket

select使用固定长度的bitmap表示文件描述符集合，个数受限。在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 `1024`，只能监听 0~1023 的文件描述符。

### poll

poll改进了select方式，使用动态数组存储文件描述符集合。但是仍然需要两次用户态和内核态之间拷贝，通过遍历方式检查可读可写。

### epoll

epoll通过两种方式，解决了select/poll问题：

- epoll 在内核里使用**红黑树**来跟踪进程所有待检测的文件描述字，可以用来保存待检测的socket，不需要重复拷贝
- epoll 使用**事件驱动**的机制，内核里维护了一个**链表来记录就绪事件**，当某个 socket 有事件发生时，通过**回调函数**内核会将其加入到这个就绪事件列表中，通过epoll_wait获取返回有事件的文件描述符个数，避免轮询查找事件。

此外epoll相比select、poll还支持了边缘触发方式，默认这三种都是选择水平触发方式。

> **水平触发**：当被监控的 Socket 上有可读事件发生时，服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束，目的是告诉我们有数据需要读取。
>
> **边缘触发**：当被监控的 Socket 描述符上有可读事件发生时，**服务器端只会从 epoll_wait 中苏醒一次**，即使没有被读取，也不会重复唤醒，所以要尽可能保证一次性读取完。

通过边缘触发方式，可以减少epoll_wait调用的方式，减少开销（上下文切换），一般为了避免由于实际文件描述符是阻塞的，没有可以读写造成进程阻塞，边缘触发一般搭配非阻塞I/O使用。

> 实际I/O多路复用一般最好搭配非阻塞I/O使用，因为多路复用 API 返回的事件并不一定可读写的，如果使用阻塞 I/O， 那么在调用 read/write 时则会发生程序阻塞。

> 后话，如果放到现在再去看去年webserver的内容，可能理解又不一样了。
