---
title: Bitcask | 实现细节
date: 2023-10-08 21:55:27
tags:
  - golang
---

## 数据库启动流程

基于Bitcask论文实现的存储引擎实例，本质上是在本地当中维护一个文件夹，这其中维护了.data结尾的数据文件。

### 参数校验

启动Bitcask时做参数校验应该考虑：

- 当前目录是否存在，是否为一个新的实例
- 对于DataFile、MergeRatio的参数合法性校验

### 文件锁

在原文当中Bitcask提出可由多个进程同时读，但是只能由一个进程写，在实际实现中为了避免并发问题，只允许一个进程进行读写操作，相当于只允许打开一个服务端。

通过系统调用flock提供的文件锁，保证多个进程之间的互斥，在启动数据库时，通过判断是否能够获取对应文件锁，来保证单个进程运行数据库。

### 初始化DB实例





### 加载merge文件

merge后的文件目录存放在父级目录同名之下的文件夹当中，如果不存在说明没有发生过合并。

如果存在merge目录，遍历目录下的文件，判断是否存在mergeFinished文件来说明merge的有效性，mergeFinished文件中存放了完成merge的文件序列号，未完成merge的部分后续需要手动加载。

在判断merge有效性后，删除旧文件，移动新文件到目录当中覆盖，最后删除merge目录。

### 加载数据文件

因为内存中维护的是key-value的数据信息在磁盘中的位置，这里需要提前加载好数据文件，后续根据Fid，Offset实现一次IO获取Value。

在本项目中将.data后缀的文件作为数据文件，并且这里根据文件名排序，实现有序数据文件，便于后续有序加载索引（记录是追加写入到磁盘中的文件的，超过datafileSize开启新的一个，同时删除是写入一条墓碑值，因此这里加载顺序很重要）。

加载到最后一个文件，是当前实例的活跃文件，所有新增或者删除记录都是追加写入到活跃文件当中的，其他文件作为oldFile只用于读。

### 加载索引

在磁盘中当中只保存了数据文件，每次打开数据库是需要重新加载索引信息到内存当中的，当然如果此时发生了merge操作，merge操作完会生成所有有效信息的一个Hint索引文件，未merge的数据文件还需要手动加载索引信息。

读取数据文件中的每一条记录，进行解码得到信息，构造Value信息：

- 解析记录的末尾序列号，如果是nonTransactionSeqNo说明是普通记录，可以更新
- 如果是事务ID，暂存记录到内存中，直到读取到事务ID结束的记录，加载这些记录到内存当中
- 记录最新的事务序列号，加载到DB实例当中，保证后续全局唯一
- 注意最后一个文件的末尾信息offset，作为活跃文件当前文件写入位置信息writeoff需要记录

在解析完Key后，如果是普通索引，或者完整事务记录信息，更新内存索引，Key：key，Value：Fid + Offset + size。

> - 在本项目中，主要结合Bitcask论文实现存储引擎实例，索引部分设计不是重点，主要利用现有的索引实现相应的功能。
> - B+树索引，使用了开源的BBlot，索引信息实际上是维护一个DB实例。每次加载数据库时，索引信息不需要通过数据文件加载，直接打开DB实例即可。
> - 由于没有读取数据文件，最新的事务序列号要通过一个seqNoFile文件进行获取，同时为了后续追加写入读取完后删除，在关闭数据库时写入一条记录到seqNoFile文件当中。

## 索引结构设计



## 数据清理



## 数据读写操作
