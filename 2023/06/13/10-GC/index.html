<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="author" content="shixiaocaia" />
  <meta name="description" content="" />
  
  
  <title>
    
      Golang | 垃圾回收机制 
      
      
      |
    
     shixiaocaia
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.ico">
    <link rel="icon" href="/images/favicon.ico">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="shixiaocaia" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.jpg" alt="">
      
    </a>
    <div class="nickname"><a href="/">shixiaocaia</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">Golang | 垃圾回收机制</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2024-01-14 17:09:30
        </span>
        
      </div>
      <div class="markdown-body">
        <blockquote>
<p>参考文章：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/TdekaMjlf_kk_ReyPvoXiQ">小徐先生的编程世界——垃圾回收原理分析</a></li>
</ol>
</blockquote>
<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>垃圾回收（Garbage Collection，简称 GC）是一种内存管理策略，由垃圾收集器以类似<strong>守护协程</strong>的方式在后台运作，按照既定的策略为用户回收那些不再被使用的对象，释放对应的内存空间。</p>
<p>通过 GC 带来的优势：</p>
<ol>
<li>屏蔽了内存回收的细节，用户只需要专注业务逻辑</li>
<li>以全局视野执行任务，减少开发者手动对模块间内存管理的负担</li>
</ol>
<p>GC不足之处，提高了下限降低了上限，增加了额外成本，但是除了处理极少数对于极致速度追究的项目，GC带来的收益是极大的。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><ol>
<li>标记清除</li>
</ol>
<ul>
<li>先标记当前存活的对象，再清扫未被标记的垃圾对象；</li>
<li>不足之处，会出现<strong>内存碎片</strong>。</li>
</ul>
<ol start="2">
<li>标记压缩</li>
</ol>
<ul>
<li>在标记清扫的基础上，会将存储对象进行压缩，使得整体空间更加紧凑，解决内存碎片问题</li>
<li>但是<strong>压缩复杂度过高</strong></li>
</ul>
<ol start="3">
<li>半空间复制</li>
</ol>
<ul>
<li>分配两片相等大小的空间，fromspace和topspace</li>
<li>每轮只使用fromspace空间，以GC划分轮次</li>
<li>GC时，将fromspace存活对象转移到topspace中，进行空间压缩</li>
<li>GC结束后，交换两个空间</li>
<li>在标记压缩基础上，降低了复杂度，但是<strong>浪费空间</strong></li>
</ul>
<ol start="4">
<li>引用次数</li>
</ol>
<ul>
<li>对象每被引用一次，计数器加1</li>
<li>对象每被删除引用一次，计数器减1</li>
<li>GC时，把计数器等于 0 的对象删除</li>
<li>不足之处，无法解决<strong>循环引用或者自引用</strong>问题，导致无法正常回收</li>
</ul>
<h2 id="Golang中的垃圾回收"><a href="#Golang中的垃圾回收" class="headerlink" title="Golang中的垃圾回收"></a>Golang中的垃圾回收</h2><p>Golang 的gc经历了以下几个版本：</p>
<ul>
<li><p>1.3版本前：普通标记清除法，整个gc过程需要启动 STW，效率极低</p>
</li>
<li><p>1.5版本：三色标记法，堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要 STW)，效率普通</p>
</li>
<li><p>1.8 版本：三色标记法，混合写屏障机制：栈空间不启动（根节点可达对象和新加入的对象全部标记成黑色），堆空间启用写屏障，整个扫描过程不要 STW，在开启和关闭写屏障时开启STW，效率高。</p>
</li>
</ul>
<h3 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h3><p>在<strong>go1.3</strong>之前采用标记清除法，从根对象出发，依次遍历对象以及子对象，标记对象的可达状态，然后清除未被标记的不可达对象，将空闲的内存加入到空闲链表中。</p>
<p>实现简单，但是标记前需要暂停程序（<strong>STW，stop the world</strong>），来避免回收写冲突问题，并且清除数据会导致内存碎片。</p>
<p>执行标记清除算法需要STW严重影响程序性能，因此在<strong>1.5</strong>版本开始，使用三色标记法来优化这个问题，支持<strong>并发垃圾回收机制</strong>。</p>
<h3 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h3><p>为了解决标记清除算法带来的长时间的STW，多数现代的垃圾收集器都会采用三色标记算法。该算法将程序中的对象分为白色、灰色和黑色三类：</p>
<ul>
<li>白色：潜在垃圾，是未被垃圾回收器访问到的对象，回收结束后，白色对象的内存会被释放</li>
<li>灰色：活跃对象，已经被垃圾回收器访问到，但存在指向白色对象的指针，需要继续访问其子对象</li>
<li>黑色：活跃对象，已经被垃圾回收器访问到，所有对象都遍历完</li>
</ul>
<p><img src="/../images/gc1.png" alt="output"></p>
<ul>
<li>第一步应用程序开始运行时，所有对象默认标记为白色</li>
<li>第二步遍历根节点（通常是协程上的对象，全局数据区的对象），把遍历到的对象标记为灰色<ul>
<li>A、E为灰色</li>
<li>其他为白色</li>
</ul>
</li>
<li>第三步遍历灰色对象，将灰色对象标记位黑色（因为他的next节点被遍历了），如果他的后继节点存在，标记为灰色（后续访问）<ul>
<li>A、E为黑色</li>
<li>B、C、F为灰色</li>
<li>其他为白色</li>
</ul>
</li>
<li>第四步重复第三步，直到灰色为空<ul>
<li>A、B、C、E、F、F为黑色</li>
<li>D、G、I、J为白色，不可达</li>
</ul>
</li>
<li>清除所有白色</li>
</ul>
<h3 id="漏标问题"><a href="#漏标问题" class="headerlink" title="漏标问题"></a>漏标问题</h3><p>因为应用程序可能在标记执行的过程中，修改对象的引用关系，所以<strong>为了保证对象不被错误回收</strong>，仍需要STW。否则可能会出现漏标和多标问题。</p>
<p>假设当前已经完成第一轮扫描，如下图所示。此时灰色对象F通过p指针指向白色对象H。</p>
<p><img src="/../images/gc2.png" alt="5ac8d27d-ed33-4af0-b55f-a178c57bedc1"></p>
<p>当对象E标记为黑色，F还未扫描，创建q指针使得对象E指向白色对象H，并移除F指向H指针。</p>
<p><img src="/../images/gc3.png" alt="94db6bea-fc0c-46ea-8db4-4d7239f21440"></p>
<p>此时由于E完成了扫描，F移除了H遍历，不会遍历到H，导致H为白色不可达，被错误回收。</p>
<p>综上分析，在不执行STW时，满足下面两个条件下会破坏垃圾收集器的正确性：</p>
<ul>
<li><p>条件1：某个黑色对象引用白色对象（q指针）</p>
</li>
<li><p>条件2：从灰色对象出发，到达白色对象的、<strong>未经访问过的路径遭到破坏</strong>（F—&gt;H)</p>
</li>
</ul>
<h3 id="多标问题"><a href="#多标问题" class="headerlink" title="多标问题"></a>多标问题</h3><p><img src="/../images/gc2.png" alt="5ac8d27d-ed33-4af0-b55f-a178c57bedc1"></p>
<p>同样可能出现多标问题。在E完成标记后置黑，F标记位灰色，在另一个时刻，一个协程删除了E对F的引用，F应该变成垃圾对象，但是由于E已经完成扫描，F最终被置为黑色，导致多标问题。</p>
<p>本该被删但仍侥幸存活的对象被称为“浮动垃圾”，至多到下一轮GC（重置标记，发现不可达），这部分对象就会被GC回收，因此错误可以得到弥补，多标问题一般可以忽略。</p>
<h2 id="屏障技术"><a href="#屏障技术" class="headerlink" title="屏障技术"></a>屏障技术</h2><p>多标问题在下一轮GC可以得到解决，而漏标问题为了避免上述问题出现，只需要达到以下两种三色不变性的一种：</p>
<ul>
<li>强三色不变性：黑色对象不会指向白色对象，只会指向灰色对象或黑色对象</li>
<li>弱三色不变性：黑色对象指向的白色对象，必须包含一条从灰色对象经由多个白色对象的可达路径</li>
</ul>
<p>当遵循强三色不变性或弱三色不变性时，我们能够保证垃圾收集的正确性，而屏障技术就是在并发或增量标记过程中保证三色不变性的重要技术。</p>
<p>Go语言在垃圾收集器的演进过程中，采用Dijkstra提出的插入写屏障和Yuasa提出的删除写屏障。</p>
<h3 id="插入写屏障"><a href="#插入写屏障" class="headerlink" title="插入写屏障"></a>插入写屏障</h3><p><img src="/../images/gc4.png" alt="图片"></p>
<p>为了避免<strong>漏标问题</strong>，引入插入写屏障，在黑色对象引入一个白色对象时，将白色对象标记为灰色，满足强三色不变性。</p>
<p>对象在内存槽中有两种位置：栈和堆。栈空间的特点是容量小，但要求响应速度快，所以Go语言<strong>没有选择启用栈上的写屏障机制</strong>。</p>
<blockquote>
<p>几乎大部分操作都在栈上完成，如果设置插入写屏障，写屏障需要执行的次数很多，比再扫描一遍成本高。</p>
</blockquote>
<h3 id="删除写屏障"><a href="#删除写屏障" class="headerlink" title="删除写屏障"></a>删除写屏障</h3><p><img src="/../images/gc5.png" alt="图片"></p>
<p>删除写屏障（Yuasa barrier）的目标是实现弱三色不变式，保证当一个白色对象即将被上游删除引用前，会触发屏障将其置灰，之后再删除上游指向其的引用，解决漏标问题。</p>
<h3 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="混合写屏障"></a>混合写屏障</h3><p>插入写屏障、删除写屏障二者择其一，即可解决并发GC的漏标问题，至于错标问题，则采用容忍态度，放到下一轮GC中进行延后处理即可。</p>
<p>但是真实场景下，屏障机制无法作用于栈对象，引入STW成本过高，为此Golang1.8引入了混合写屏障：</p>
<ul>
<li>GC 开始前，以栈为单位分批扫描，将栈中所有对象置黑</li>
<li>GC 期间，栈上新创建对象直接置黑</li>
<li>堆对象正常启用插入写屏障</li>
<li>堆对象正常启用删除写屏障</li>
</ul>
<p>可以看<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/TdekaMjlf_kk_ReyPvoXiQ">小徐先生的编程世界——垃圾回收原理分析</a>，通过混合写屏障，保障了在栈上不会出现漏标问题，而多标问题延后处理。</p>
<blockquote>
<p>通常，在垃圾回收的扫描阶段开始时，栈上的对象会被认为是根对象（root objects）。因为它们是从根开始的可达对象，所以要被标记为黑色。根对象通常是不可回收的，因为它们是当前执行上下文的一部分，并且引用其他对象。</p>
</blockquote>
<h2 id="golang如何解决内存碎片问题"><a href="#golang如何解决内存碎片问题" class="headerlink" title="golang如何解决内存碎片问题"></a>golang如何解决内存碎片问题</h2><p>golang采用标记清扫算法，但是标记清扫算法会出现内存碎片问题，如何化解这一问题：</p>
<p>golang采用tcmalloc机制，实现将内存分块到不同的spanClass，申请时分配合适大小的块，将问题限制在可控的范围。词用采用更为简单的标记清除法，比标记压缩算法复杂度低很多。</p>
<h2 id="有了GC是否不会发生内存泄露"><a href="#有了GC是否不会发生内存泄露" class="headerlink" title="有了GC是否不会发生内存泄露"></a>有了GC是否不会发生内存泄露</h2><p>不一定，当预期能够很快被释放的内存，由于附着在长期存活的内存、或生命期被意外延长，依然会导致长时间得不到回收。比如：</p>
<ul>
<li>预期能被快速释放的内存因被根对象引用而没有得到迅速的释放</li>
<li>当有一个全局对象时，可能不经意间将某个变量附着在其上，且忽略释放该变量，则其内存永远不会得到释放。</li>
<li>Goroutine作为一种逻辑上理解的轻量级线程，需要维护执行用户代码的上下文信息。在运行过程中也需要消耗一定的内存来保存这些信息，而这些内存在目前版本的Go语言是不会被释放的。因此，当一个程序持续不断地产生新的Goroutine、且不结束已创建的Goroutine并复用这部分内存，就会造成内存泄露的现象</li>
</ul>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2023/06/12/9-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2024-01-14 17:09:30
            </span>
            
          </div>
          <div class="post-foot-prev">
            
              <a href="/2023/07/12/5-MQ/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D"><span class="toc-text">背景介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-text">垃圾回收算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Golang%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">Golang中的垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E6%B3%95"><span class="toc-text">标记清除法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95"><span class="toc-text">三色标记法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%A0%87%E9%97%AE%E9%A2%98"><span class="toc-text">漏标问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%A0%87%E9%97%AE%E9%A2%98"><span class="toc-text">多标问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%8F%E9%9A%9C%E6%8A%80%E6%9C%AF"><span class="toc-text">屏障技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="toc-text">插入写屏障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="toc-text">删除写屏障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="toc-text">混合写屏障</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#golang%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98"><span class="toc-text">golang如何解决内存碎片问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E4%BA%86GC%E6%98%AF%E5%90%A6%E4%B8%8D%E4%BC%9A%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-text">有了GC是否不会发生内存泄露</span></a></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/shixiaocaia">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/shixiaocaia">Copyright © 2024 shixiaocaia</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        

      </div>
    </div>
  </body>
</html>
